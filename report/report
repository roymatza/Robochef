#RoboChef -  Temporal Planning in a Kitchen Environment#

##What is RoboChef?##
RoboChef project takes advantage of AI techniques and the *AI2Thor* simulation environement with the aim of simply and efficiently execute a task in the kitchen by planning in advance. The robot's main task is to move around different kinds of foods and tools, interact with them in the manner of cooking, toggling, cleaning etc., and possiblly serve them, all of this given a specific definition of the durations (whether by a fixed number or a range) of all of the involved actions.

##Progress##
###Step 1: Kitchen Environment in PDDL###
Following a model-based approach, our agent is given a model that includes objects, predicates, and possible actions in the world.
Written in PDDL language, we assume as a start that the environment is fully observablewith the aim of making a 'simple breakfast i.e., cooking eggs and making coffee, and serve them onto a table. Modelling the environment required object arrangement in a hierarchical manner (cookware, surfaces, receptacles, etc.). This step was crucial since each object could be applied in a differnet way, thus our planner should consider the applicable manner of using the objects. This process of defining the types and predicates intended to be interchangeable with the types and states of the AI2THOR simulation environment. A PDDL domain file with the proper actions for making the simple breakfast was successfully created and solved. 

![d](~home/royboy18/Pictures/Screenshot from 2021-09-12 12-10-59.png) 

###Step 2: Scene Modelling and Problem File Generation###
In order to try and plan on an actual scene, there should be a mechanism that fetches the environment information and transforms it to a problem file in the strict format of a PDDL. Therefore, many python code lines were written to enable quality generation of PDDL file based on what we know of the environment (this is encapsuled by 'metadata' of the ai2thor framework). The concept of implementation focused on maintaining an individual knowledge base that conatins objects and predicates of our concern (as this would be very confusing and complex to hold the state of a lamp when we need to make breakfast).
Prior to creating a problem file, it is mandatory to make some verifications of our tasks (what we ask the agent to do) based on our current knowledge about the environment. This process runs some checks in the simulation enviroment to check if all the initial conditions that are required to initiate the task are fulfilled. If there's some problem, the user is notified about it. On the same occasion, all true predicates are stored for future use since they should be considered as well by the agent in the planning process. Having completed all background checks, it is time to proceed to problem file generation.
A de facto problem file generation occurs by an open-source template engine called [Jinja2](https://jinja.palletsprojects.com/en/3.0.x/templates/)  (Â© Copyright 2007 Pallets) that parses raw data from the simulation environement into a template of a PDDL problem file. The engine takes into account all relevant data for the planning procedure. Wrapping up the python modules with the template engine functionality, an interface between AI2THOR and a generic PDDL planner is produced.

###Step 3: Planning and Dispatching Actions in Python###
The next step was deciding of planners to be used during program execution. Unfortunately, due to limited compatability and flexibility of planner with new development environment, I've decided to stick with [LPG-TD](https://lpg.unibs.it/lpg/) planner, that is an extention of LPG planner (Gereveni, Saetti & Serina) which can handle most of the features of PDDL 2.2. LPG-TD supports most features of classic and temporal planning. Planners commonly yield *plan files* which specify the chain of actions (and possible their cost and duration) until the goal is reached. Robochef implements a dispatcher that maps each PDDL action to AI2THOR action/s. This is a simple mapping that takes the name of the action and matches the relevant method (sometimes written manually). This process is iterative until the last action, and can be shown in the graphic scene.